# `dinh/zybo_memcopy_accel_interrupt/src/Vitis-BareMetal/` 코드 리뷰 보고서

이 보고서는 `zybo_memcopy_accel_interrupt` 프로젝트의 베어메탈 애플리케이션 소스 코드에 대한 상세한 코드 리뷰 결과를 담고 있습니다. 이 폴더에는 메인 애플리케이션(`main.c`), 가속기 드라이버(`memcopy_accel.c`), 그리고 드라이버 헤더(`memcopy_accel.h`)가 포함되어 있습니다.

---

# `memcopy_accel.h` 코드 리뷰 보고서

이 헤더 파일은 HLS로 생성된 memcopy_accel IP의 레지스터 맵과 드라이버 API를 정의합니다.

## 1. 레지스터 맵 정의

```c
#ifndef MEMCOPY_ACCEL_BASEADDR
#define MEMCOPY_ACCEL_BASEADDR 0x40000000u
#endif

/* Register offsets generated by Vivado HLS (typical layout) */
#define MEMCOPY_ACCEL_CTRL_OFFSET   0x00u   /* Control (ap_start, ap_done, etc.) */
#define MEMCOPY_ACCEL_GIE_OFFSET    0x04u   /* Global Interrupt Enable */
#define MEMCOPY_ACCEL_IER_OFFSET    0x08u   /* IP Interrupt Enable */
#define MEMCOPY_ACCEL_ISR_OFFSET    0x0Cu   /* IP Interrupt Status */
#define MEMCOPY_ACCEL_SRC_OFFSET    0x10u   /* src (lower 32 bits) */
#define MEMCOPY_ACCEL_DST_OFFSET    0x1cu   /* dst (lower 32 bits) */
#define MEMCOPY_ACCEL_LEN_OFFSET    0x28u   /* len (bytes) */
```

### 1.1 레지스터 구조 분석

| 오프셋 | 레지스터 | 설명 |
|--------|----------|------|
| 0x00 | CTRL | 제어 레지스터 (ap_start, ap_done, ap_idle, ap_ready) |
| 0x04 | GIE | 글로벌 인터럽트 활성화 |
| 0x08 | IER | IP 인터럽트 활성화 |
| 0x0C | ISR | IP 인터럽트 상태 (write-to-clear) |
| 0x10 | SRC | 소스 주소 (하위 32비트) |
| 0x1C | DST | 목적지 주소 (하위 32비트) |
| 0x28 | LEN | 복사할 바이트 수 |

*   **주소 갭**: SRC(0x10)와 DST(0x1C) 사이, DST(0x1C)와 LEN(0x28) 사이에 갭이 있습니다. 이는 64비트 주소를 위한 상위 비트 레지스터가 예약되어 있음을 나타냅니다 (0x14, 0x20 등).

## 2. 제어 비트 마스크

```c
/* Control bits */
#define MEMCOPY_AP_START_MASK       0x01u
#define MEMCOPY_AP_DONE_MASK        0x02u
#define MEMCOPY_AP_IDLE_MASK        0x04u
#define MEMCOPY_AP_READY_MASK       0x08u
#define MEMCOPY_AUTO_RESTART_MASK   0x80u

/* Global Interrupt Enable bit mask */
#define MEMCOPY_GIE_ENABLE_MASK     0x01u

/* IP Interrupt Enable bit mask */
#define MEMCOPY_IER_CHAN0_INT_EN_MASK   0x01u
#define MEMCOPY_IER_CHAN1_INT_EN_MASK   0x02u

/* IP Interrupt Status bit mask */
#define MEMCOPY_ISR_CHAN0_INT_CLEAR_MASK  0x01u
```

### 2.1 제어 비트 설명

| 비트 | 마스크 | 기능 |
|------|--------|------|
| ap_start | 0x01 | IP 실행 시작 (write 1) |
| ap_done | 0x02 | 실행 완료 플래그 (read only) |
| ap_idle | 0x04 | 유휴 상태 (read only) |
| ap_ready | 0x08 | 새 입력 수락 가능 (read only) |
| auto_restart | 0x80 | 자동 재시작 모드 |

### 2.2 인터럽트 사용 가이드

```c
/*How to Use Interrupts Registers
1. Enable global interrupts by writing 1 to GIER.
2. Enable channel-specific interrupts by setting bits in IP_IER.
3. Monitor interrupt status using IP_ISR.
4. Clear interrupt status (if supported) by writing 1 to the corresponding bit in IP_ISR.
*/
```

## 3. API 프로토타입

```c
void memcopy_accel_init(uint32_t baseaddr);
void memcopy_accel_start(uint32_t src_addr, uint32_t dst_addr, uint32_t len);
bool memcopy_accel_is_done(void);
void memcopy_accel_wait_done(void);
int memcopy_accel_copy_polling(uint32_t src_addr, uint32_t dst_addr, uint32_t len);

/* Interrupt helpers */
void memcopy_accel_interrupt_enable(void);
void memcopy_accel_interrupt_clear(void);
```

---

# `memcopy_accel.c` 코드 리뷰 보고서

이 파일은 memcopy_accel IP를 제어하는 드라이버 구현입니다.

## 1. 드라이버 초기화

```c
static uint32_t base_addr = MEMCOPY_ACCEL_BASEADDR;

void memcopy_accel_init(uint32_t baseaddr)
{
    base_addr = baseaddr;
}
```

*   **정적 베이스 주소**: 모듈 내부에 베이스 주소를 저장하여 이후 함수 호출에서 사용합니다.
*   **유연성**: `memcopy_accel_init()`을 통해 런타임에 베이스 주소를 변경할 수 있습니다.

## 2. 가속기 시작

```c
void memcopy_accel_start(uint32_t src_addr, uint32_t dst_addr, uint32_t len)
{
    /* Write parameters */
    Xil_Out32(base_addr + MEMCOPY_ACCEL_SRC_OFFSET, src_addr);
    Xil_Out32(base_addr + MEMCOPY_ACCEL_DST_OFFSET, dst_addr);
    Xil_Out32(base_addr + MEMCOPY_ACCEL_LEN_OFFSET, len);
    /* Start IP (write ap_start = 1) */
    Xil_Out32(base_addr + MEMCOPY_ACCEL_CTRL_OFFSET, MEMCOPY_AP_START_MASK);
}
```

### 2.1 실행 순서

1.  소스 주소 설정 (SRC 레지스터)
2.  목적지 주소 설정 (DST 레지스터)
3.  길이 설정 (LEN 레지스터)
4.  ap_start 비트 설정으로 실행 시작

*   **`Xil_Out32`**: Xilinx BSP에서 제공하는 32비트 메모리 매핑 I/O 쓰기 함수입니다.

## 3. 완료 상태 확인

```c
bool memcopy_accel_is_done(void)
{
    uint32_t ctrl = Xil_In32(base_addr + MEMCOPY_ACCEL_CTRL_OFFSET);
    return (ctrl & MEMCOPY_AP_DONE_MASK) != 0;
}

void memcopy_accel_wait_done(void)
{
    /* Poll ap_done */
    while (!memcopy_accel_is_done()) { /* busy wait */ }
    /* Clear ap_start (write 0) */
    Xil_Out32(base_addr + MEMCOPY_ACCEL_CTRL_OFFSET, 0x0);
}
```

*   **폴링 방식**: `memcopy_accel_is_done()`으로 ap_done 비트를 폴링합니다.
*   **비지 웨이트**: CPU가 완료될 때까지 무한 루프를 돕니다 (전력 비효율적).

## 4. 폴링 기반 복사 함수

```c
int memcopy_accel_copy_polling(uint32_t src_addr, uint32_t dst_addr, uint32_t len)
{
    memcopy_accel_start(src_addr, dst_addr, len);
    memcopy_accel_wait_done();
    return 0;
}
```

*   **블로킹 API**: 시작부터 완료까지 블로킹되는 동기식 인터페이스를 제공합니다.

## 5. 인터럽트 헬퍼 함수

```c
void memcopy_accel_interrupt_enable(void)
{
    Xil_Out32(base_addr + MEMCOPY_ACCEL_GIE_OFFSET, MEMCOPY_GIE_ENABLE_MASK);
    Xil_Out32(base_addr + MEMCOPY_ACCEL_IER_OFFSET, MEMCOPY_IER_CHAN0_INT_EN_MASK);
}

void memcopy_accel_interrupt_clear(void)
{
    Xil_Out32(base_addr + MEMCOPY_ACCEL_ISR_OFFSET, MEMCOPY_ISR_CHAN0_INT_CLEAR_MASK);
}
```

### 5.1 인터럽트 활성화 순서

1.  **GIE 활성화**: 글로벌 인터럽트 활성화 (GIER에 1 쓰기)
2.  **채널 활성화**: 채널 0 인터럽트 활성화 (IER에 1 쓰기)

### 5.2 인터럽트 클리어

*   **Write-to-Clear**: ISR 레지스터에 1을 쓰면 해당 비트가 클리어됩니다.
*   **Zynq 특성상 추가 처리 필요**: 메인 코드에서 ISR 클리어 후 더미 읽기가 필요합니다.

---

# `main.c` 코드 리뷰 보고서

이 파일은 memcopy_accel 가속기를 테스트하는 베어메탈 데모 애플리케이션입니다.

## 1. 헤더 및 상수 정의

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "xparameters.h"
#include "xil_io.h"
#include "xil_cache.h"
#include "xil_printf.h"
#include "xtime_l.h"
#include "xscugic.h"
#include "xil_exception.h"
#include "memcopy_accel.h"

#define INTC_DEVICE_ID         XPAR_SCUGIC_SINGLE_DEVICE_ID
#define MEMCOPY_ACCEL_INTR_ID  XPAR_FABRIC_MEMCOPY_ACCEL_0_INTERRUPT_INTR
```

### 1.1 Xilinx BSP 헤더

| 헤더 | 용도 |
|------|------|
| `xparameters.h` | 하드웨어 설정 매크로 |
| `xil_io.h` | 메모리 매핑 I/O |
| `xil_cache.h` | 캐시 관리 |
| `xil_printf.h` | 경량 printf |
| `xtime_l.h` | 고정밀 시간 측정 |
| `xscugic.h` | GIC 인터럽트 컨트롤러 |
| `xil_exception.h` | 예외 처리 |

## 2. 베이스 주소 설정

```c
#ifndef XPAR_MEMCOPY_ACCEL_0_BASEADDR
#define MEMCOPY_BASE MEMCOPY_ACCEL_BASEADDR
#else
#define MEMCOPY_BASE XPAR_MEMCOPY_ACCEL_0_BASEADDR
#endif
```

*   **자동 감지**: BSP에서 생성된 주소가 있으면 사용하고, 없으면 드라이버 기본값을 사용합니다.

## 3. CPU memcpy 참조 구현

```c
void cpu_memcopy(uint32_t* src, uint32_t* dst, uint32_t len_bytes) {
    uint32_t num_words = len_bytes / 4;
    for (uint32_t i = 0; i < num_words; i++) {
        dst[i] = src[i];
    }
}
```

*   **성능 비교 용도**: 하드웨어 가속기와 CPU 복사 성능을 비교하기 위한 참조 구현입니다.
*   **단순 구현**: 최적화 없이 단순한 워드 단위 복사를 수행합니다.

## 4. 인터럽트 서비스 루틴 (ISR)

```c
static volatile int memcopy_done = 0;

void memcopy_isr(void *CallbackRef)
{
    memcopy_accel_interrupt_clear();
    
    // Read-back to flush AXI write and avoid IRQ retrigger (required on Zynq)
    (void)Xil_In32(MEMCOPY_BASE + MEMCOPY_ACCEL_ISR_OFFSET);
    
    memcopy_done = 1;
}
```

### 4.1 ISR 동작 분석

1.  **인터럽트 클리어**: `memcopy_accel_interrupt_clear()` 호출
2.  **더미 읽기 (메모리 배리어)**: ISR 레지스터 읽기
3.  **완료 플래그 설정**: `memcopy_done = 1`

### 4.2 더미 읽기의 중요성

```c
/*
 * Why This Fix Works
 * AXI-Lite writes are posted transactions — they can take several cycles 
 * to propagate from the ARM core (PS) to the PL IP.
 * When the ISR returned too quickly, the interrupt signal (ap_done) was 
 * still asserted for a few cycles, so the GIC saw the line still high 
 * and re-entered the ISR instantly (interrupt storm).
 * By performing a dummy read right after writing 1 to clear the ISR, 
 * you flush the AXI write buffer, forcing the hardware to complete the 
 * clear before leaving the ISR.
 */
```

*   **문제**: AXI-Lite 쓰기는 포스트 트랜잭션으로, ISR 클리어가 완료되기 전에 ISR이 반환되면 인터럽트가 다시 발생합니다.
*   **해결**: 더미 읽기가 AXI 쓰기 버퍼를 플러시하여 클리어가 완료된 후에만 ISR이 종료됩니다.

## 5. 인터럽트 시스템 설정

```c
int setup_interrupt_system(void)
{
    XScuGic_Config *IntcConfig;
    int Status;

    IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (IntcConfig == NULL)
        return XST_FAILURE;

    Status = XScuGic_CfgInitialize(&Intc, IntcConfig, IntcConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS)
        return XST_FAILURE;

    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 &Intc);

    Status = XScuGic_Connect(&Intc,
                             MEMCOPY_ACCEL_INTR_ID,
                             (Xil_ExceptionHandler)memcopy_isr,
                             NULL);
    if (Status != XST_SUCCESS)
        return XST_FAILURE;

    XScuGic_Enable(&Intc, MEMCOPY_ACCEL_INTR_ID);
    Xil_ExceptionEnable();
    memcopy_accel_interrupt_enable();
    
    return XST_SUCCESS;
}
```

### 5.1 GIC 초기화 순서

1.  **설정 조회**: `XScuGic_LookupConfig()`
2.  **초기화**: `XScuGic_CfgInitialize()`
3.  **예외 핸들러 등록**: `Xil_ExceptionRegisterHandler()`
4.  **ISR 연결**: `XScuGic_Connect()`
5.  **인터럽트 활성화**: `XScuGic_Enable()`, `Xil_ExceptionEnable()`
6.  **IP 인터럽트 활성화**: `memcopy_accel_interrupt_enable()`

## 6. 메인 함수

### 6.1 버퍼 할당 및 초기화

```c
const uint32_t NUM_WORDS = 8192; /* 8192 * 4 = 32768 bytes (32KB) */
const uint32_t BYTE_LEN = NUM_WORDS * 4;

uint32_t *src_buf = (uint32_t *)malloc(BYTE_LEN);
uint32_t *dst_buf = (uint32_t *)malloc(BYTE_LEN);
uint32_t *dst_buf_cpu = (uint32_t *)malloc(BYTE_LEN);

/* Fill source with pattern and clear destination */
for (uint32_t i = 0; i < NUM_WORDS; ++i) {
    src_buf[i] = 0xA5A50000u | i;
    dst_buf[i] = 0x0;
    dst_buf_cpu[i] = 0x0;
}
```

*   **테스트 크기**: 32KB (8192 워드)
*   **소스 패턴**: `0xA5A5xxxx` (상위 16비트 고정 + 인덱스)
*   **목적지 초기화**: 0으로 클리어

### 6.2 캐시 관리

```c
/* Cache maintenance:
   - Flush source region so PL (via HP port) sees latest data
   - Flush destination region as well to avoid dirty data being written back */
Xil_DCacheFlushRange((unsigned int)src_buf, BYTE_LEN);
Xil_DCacheFlushRange((unsigned int)dst_buf, BYTE_LEN);
Xil_DCacheFlushRange((unsigned int)dst_buf_cpu, BYTE_LEN);
```

*   **소스 플러시**: CPU 캐시의 데이터를 DDR에 기록하여 PL이 최신 데이터를 읽을 수 있게 합니다.
*   **목적지 플러시**: 더티 데이터가 나중에 기록되어 결과를 덮어쓰는 것을 방지합니다.

### 6.3 가속기 실행 및 대기

```c
memcopy_done = 0;
memcopy_accel_start((uint32_t)src_buf, (uint32_t)dst_buf, BYTE_LEN);

/* Sleep until an interrupt wakes the CPU; avoid busy-wait */
do {
    __asm__ volatile ("wfi");   // wakes on any IRQ
} while (!memcopy_done);
```

*   **WFI 명령어**: CPU를 저전력 대기 상태로 전환하여 전력을 절약합니다.
*   **인터럽트 기반**: ISR에서 `memcopy_done = 1`을 설정하면 루프가 종료됩니다.

### 6.4 결과 검증

```c
/* Invalidate to discard stale cache and read updated data */
Xil_DCacheInvalidateRange((unsigned int)dst_buf, BYTE_LEN);

int errors = 0;
for (uint32_t i = 0; i < NUM_WORDS; ++i) {
    if (dst_buf[i] != src_buf[i]) {
        xil_printf("Mismatch at idx %u: src=0x%08x dst=0x%08x\r\n",
                   i, src_buf[i], dst_buf[i]);
        errors++;
        if (errors > 10) break;
    }
}
```

*   **캐시 무효화**: PL이 기록한 데이터를 CPU가 읽기 위해 캐시를 무효화합니다.
*   **오류 제한**: 10개 초과 오류 시 조기 종료하여 출력 범람을 방지합니다.

### 6.5 성능 비교

```c
XTime_GetTime(&tStart);
cpu_memcopy(src_buf, dst_buf_cpu, BYTE_LEN);
XTime_GetTime(&tEnd);
uint32_t time_cpu = (uint32_t)((tEnd - tStart) / (COUNTS_PER_SECOND / 1000000));

xil_printf("CPU memcpy done in %d us\r\n", time_cpu);
xil_printf("Accelerator memcpy done in %d us\r\n", time_accel);
```

*   **마이크로초 변환**: CPU 사이클을 마이크로초로 변환합니다.
*   **비교 출력**: CPU와 가속기의 실행 시간을 비교합니다.

---

# 코드 품질 및 최적화 고려사항

## 장점

1.  **완전한 인터럽트 지원**: 폴링 대신 인터럽트 기반으로 CPU 효율을 높입니다.

2.  **WFI 절전 모드**: CPU가 유휴 상태에서 전력을 절약합니다.

3.  **철저한 캐시 관리**: 플러시와 무효화를 적절히 사용하여 데이터 일관성을 보장합니다.

4.  **ISR 메모리 배리어**: 더미 읽기로 인터럽트 스톰을 방지하는 중요한 기법을 적용했습니다.

5.  **성능 비교**: CPU memcpy와 가속기 성능을 직접 비교할 수 있습니다.

## 개선 제안

### 1. 64비트 주소 지원

```c
// 현재 코드 (32비트만 지원)
Xil_Out32(base_addr + MEMCOPY_ACCEL_SRC_OFFSET, src_addr);

// 개선된 코드 (64비트 지원)
Xil_Out32(base_addr + MEMCOPY_ACCEL_SRC_OFFSET, (uint32_t)src_addr);
Xil_Out32(base_addr + MEMCOPY_ACCEL_SRC_OFFSET + 4, (uint32_t)(src_addr >> 32));
```

### 2. 타임아웃 처리

```c
// 현재 코드 (무한 대기)
do {
    __asm__ volatile ("wfi");
} while (!memcopy_done);

// 개선된 코드 (타임아웃 포함)
XTime timeout_end;
XTime_GetTime(&timeout_end);
timeout_end += TIMEOUT_CYCLES;

do {
    __asm__ volatile ("wfi");
    XTime now;
    XTime_GetTime(&now);
    if (now > timeout_end) {
        xil_printf("ERROR: Timeout waiting for accelerator\r\n");
        break;
    }
} while (!memcopy_done);
```

### 3. 메모리 정렬 검증

```c
// 버퍼가 캐시 라인 정렬되었는지 확인
#define CACHE_LINE_SIZE 64
src_buf = (uint32_t *)aligned_alloc(CACHE_LINE_SIZE, BYTE_LEN);
```

### 4. 오류 카운터 타입 수정

```c
// 현재: dst_buf_cpu 검증 시 dst_buf와 비교 (버그)
if (dst_buf[i] != src_buf[i]) {  // dst_buf_cpu가 아닌 dst_buf 사용
    xil_printf("Mismatch ... dst=0x%08x\r\n", dst_buf_cpu[i]);
}

// 수정된 코드
if (dst_buf_cpu[i] != src_buf[i]) {
    xil_printf("Mismatch ... dst=0x%08x\r\n", dst_buf_cpu[i]);
}
```

---

# 결론

`Vitis-BareMetal/` 폴더의 코드는 Zybo Z7-10 보드에서 HLS 생성 memcopy_accel IP를 제어하는 완전한 베어메탈 드라이버 및 데모 애플리케이션을 제공합니다.

*   **`memcopy_accel.h`**: HLS IP의 레지스터 맵과 제어 비트를 명확하게 정의하며, 인터럽트 사용 가이드를 포함합니다.

*   **`memcopy_accel.c`**: 초기화, 시작, 완료 대기, 인터럽트 제어 등 완전한 드라이버 API를 제공합니다.

*   **`main.c`**: 인터럽트 기반 실행, WFI 절전 모드, 철저한 캐시 관리를 포함한 프로덕션 수준의 데모를 구현합니다. 특히 ISR의 더미 읽기 메모리 배리어는 Zynq 플랫폼에서 흔히 발생하는 인터럽트 스톰 문제를 해결하는 중요한 기법입니다.

이 코드는 `Vitis-HLS/` 폴더의 하드웨어 구현과 함께 완전한 하드웨어-소프트웨어 시스템을 구성하며, FPGA 가속기 개발의 모범적인 예시를 제공합니다.
